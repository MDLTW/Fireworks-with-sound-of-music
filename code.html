<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>史詩級！1812序曲煙火交響秀 (60秒循環)</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; }
        canvas { display: block; background-color: #000; }
        #sound-prompt {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.75); color: white; display: flex;
            justify-content: center; align-items: center; font-size: 2em;
            text-align: center; padding: 20px; box-sizing: border-box;
            cursor: pointer; z-index: 10;
        }
    </style>
</head>
<body>
    <div id="sound-prompt">
        🎆<br>點擊螢幕任何地方<br>開啟聲音並開始煙火交響秀！
    </div>

    <canvas id="fireworksCanvas"></canvas>

    <!-- 聲音檔案 -->
    <!-- *** 非常重要：確認 src 路徑和檔名跟你上傳的一樣！*** -->
    <audio id="bgMusic" src="audio/1812_finale.mp3" preload="auto" loop></audio>
    <audio id="fireworksSfxLoop" src="audio/fireworks_sfx_20s.mp3" preload="auto" loop></audio>

    <script>
        const canvas = document.getElementById('fireworksCanvas');
        const ctx = canvas.getContext('2d');
        let activeFireworks = [];
        let vw, vh;
        let mainLoopTimer = 0;
        let sequenceIndex = 0;
        let lastTime = 0;

        // --- 聲音相關變數 ---
        let bgMusic;
        let fireworksSfxLoop; // 用來控制煙火音效循環
        let soundEnabled = false;
        let soundPrompt;

        // --- 核心設定 ---
        const sequenceDuration = 60000;
        const targetFireworksPerSequence = 800;
        const gravity = 0.03;
        const friction = 0.98;
        const trailLength = 8;

        // --- 顏色庫 ---
        const colors = [ /* ... 省略，顏色列表和之前一樣 ... */
            '#FF4848', '#FF7648', '#FFA548', '#FFD048', '#FFFF48',
            '#48FFFF', '#48D1FF', '#48A5FF', '#4876FF', '#4848FF', '#7648FF',
            '#48FF48', '#48FF76', '#48FFA5', '#48FFD1',
            '#FF48FF', '#FF48D1', '#FF48A5', '#D148FF', '#A548FF',
            '#FFFFFF', '#F0F0F0', '#FFD700'
        ];

        // --- 煙火類型 ---
        const fireworkTypes = [ /* ... 省略，類型列表和之前一樣 ... */
            'sphere_mono', 'sphere_multi', 'sphere_rainbow',
            'willow_gold', 'willow_multi',
            'glitter_fast', 'glitter_dense',
            'strobe_mono', 'strobe_multi',
            'ring_simple',
            'burst_directional',
            'sphere_compact', 'sphere_large'
        ];

        // --- 預生成序列 ---
        let fireworkSequence = [];
        function generateSequence() { /* ... 省略，內容和之前一樣 ... */
            console.log("Generating 60s firework sequence...");
            fireworkSequence = [];
            if (!vw || !vh) { resizeCanvas(); }
            for (let i = 0; i < targetFireworksPerSequence; i++) {
                const launchTime = Math.random() * sequenceDuration;
                const xPos = random(0.1, 0.9);
                const type = fireworkTypes[Math.floor(Math.random() * fireworkTypes.length)];
                const launchSpeed = random(-12, -16);
                const targetHeightFactor = random(0.15, 0.5);
                fireworkSequence.push({
                    time: launchTime, x: xPos, type: type,
                    launchSpeed: launchSpeed, targetHeightFactor: targetHeightFactor
                });
            }
            fireworkSequence.sort((a, b) => a.time - b.time);
            console.log(`Generated ${fireworkSequence.length} firework events.`);
            sequenceIndex = 0;
        }


        // --- 輔助函數 ---
        function random(min, max) { /* ... 省略 ... */ return Math.random() * (max - min) + min; }
        function randomInt(min, max) { /* ... 省略 ... */ return Math.floor(random(min, max + 1)); }
        function randomColor(palette = colors) { /* ... 省略 ... */ return palette[Math.floor(Math.random() * palette.length)]; }
        function getColors(type) { /* ... 省略，內容和之前一樣 ... */
             let count = randomInt(1,3);
             let palette = colors;
             if (type.includes('mono')) count = 1;
             if (type.includes('multi')) count = randomInt(2, 4);
             if (type.includes('rainbow')) return ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#8B00FF'];
             if (type.includes('gold')) return ['#FFD700', '#FFA500', '#F0E68C'];
             const shuffled = palette.slice().sort(() => 0.5 - Math.random());
             return shuffled.slice(0, count);
        }

        // --- 粒子類別 ---
        class Particle { /* ... 省略，內容和之前一樣 ... */
             constructor(x, y, vx, vy, color, life, particleType = 'normal', options = {}) {
                this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.color = color;
                this.initialLife = life > 0 ? life : 0.1; this.life = this.initialLife; this.alpha = 1;
                this.type = particleType; this.gravity = gravity * (options.gravityFactor || 1);
                this.friction = options.friction || friction; this.strobeRate = options.strobeRate || 0.1;
                this.strobeIntensity = options.strobeIntensity || 0.5; this.radius = options.radius || random(1.5, 2.5);
                this.decay = random(0.01, 0.02) * (options.decayRate || 1);
                if (this.decay * (16.67) >= this.life) { this.decay = this.life / 20 ; }
            }
             update(deltaTime) { /* ... 省略，內容和之前一樣 ... */
                 if (isNaN(deltaTime) || deltaTime <= 0) deltaTime = 16.67;
                 const dt = deltaTime / 16.67;
                 this.x += this.vx * dt; this.y += this.vy * dt; this.vy += this.gravity * dt;
                 this.vx *= Math.pow(this.friction, dt); this.vy *= Math.pow(this.friction, dt);
                 this.life -= this.decay * dt;
                 if (this.type === 'strobe') { /* ... strobe alpha logic ... */
                     if (Math.random() < this.strobeRate) { this.alpha = random(1 - this.strobeIntensity, 1); }
                     else { const baseAlpha = this.initialLife > 0 ? Math.max(0, this.life / (this.initialLife * 0.5)) : 0; this.alpha = baseAlpha; }
                     this.alpha = Math.max(0, Math.min(1, this.alpha));
                 } else { this.alpha = this.initialLife > 0 ? Math.max(0, this.life / this.initialLife) : 0; }
                 this.alpha = Math.max(0, this.alpha);
             }
             draw() { /* ... 省略，內容和之前一樣 ... */
                 ctx.globalAlpha = this.alpha; ctx.fillStyle = this.color; ctx.beginPath();
                 ctx.arc(this.x, this.y, this.radius * this.alpha + 0.5, 0, Math.PI * 2); ctx.fill();
             }
             shouldRemove() { /* ... 省略，內容和之前一樣 ... */ return this.life <= 0 || this.alpha <= 0.01; }
        }

        // --- 煙火類別 ---
        class Firework {
            constructor(startX, targetY, launchSpeed, type) { // *** 注意：接收的是計算好的 targetY ***
                this.startX = startX;
                this.targetHeight = targetY; // 直接使用傳入的絕對高度
                this.type = type;
                this.exploded = false;
                this.particles = [];
                this.rocket = { x: startX, y: vh, vx: random(-1, 1), vy: launchSpeed, alpha: 1, color: 'rgba(255,255,255,0.5)' };
                this.trailParticles = [];
                this.explosionParams = this.getExplosionParams(type);
                this.explosionColors = getColors(type);
            }

            getExplosionParams(type) { /* ... 省略，內容和之前一樣 ... */
                let params = { /* ... defaults ... */ count: randomInt(80, 150), speed: random(3, 8), life: random(0.8, 1.8), particleType: 'normal', gravityFactor: 1, radius: random(1.5, 2.5), decayRate: 1, shape: 'sphere', angleRange: [0, Math.PI * 2] };
                if (type.includes('willow')) { /* ... */ params.count = randomInt(60, 120); params.speed = random(1, 4); params.life = random(2.0, 3.5); params.gravityFactor = 1.2; params.decayRate = 0.8; params.radius = random(1, 2); }
                else if (type.includes('glitter')) { /* ... */ params.count = randomInt(150, 300); params.speed = random(4, 9); params.life = random(0.3, 0.8); params.decayRate = 1.5; params.radius = random(0.8, 1.5); }
                else if (type.includes('strobe')) { /* ... */ params.particleType = 'strobe'; params.life = random(0.6, 1.5); params.strobeRate = 0.2; params.strobeIntensity = 0.6; }
                else if (type.includes('ring')) { /* ... */ params.shape = 'ring'; const ringStart = Math.random() * Math.PI * 2; const ringWidth = random(Math.PI * 0.1, Math.PI * 0.3); params.angleRange = [ringStart, ringStart + ringWidth]; params.count = randomInt(100, 180); params.speed = random(4, 7); }
                else if (type.includes('directional')) { /* ... */ params.shape = 'directional'; const direction = Math.random() * Math.PI * 2; const spread = random(Math.PI * 0.3, Math.PI * 0.8); params.angleRange = [direction - spread / 2, direction + spread / 2]; params.speed = random(6, 11); }
                if(type.includes('compact')) { /* ... */ params.speed = random(2, 5); params.life = random(0.6, 1.2); params.count = randomInt(60,100); }
                if(type.includes('large')) { /* ... */ params.speed = random(5, 10); params.life = random(1.5, 2.5); params.count = randomInt(120, 200); }
                return params;
            }

            update(deltaTime) { // *** 內容不變，但不再需要從這裡觸發音效 ***
                const dt = deltaTime / 16.67;
                if (!this.exploded) {
                    this.rocket.x += this.rocket.vx * dt;
                    this.rocket.y += this.rocket.vy * dt;
                    this.rocket.vy += gravity * dt;
                    if(Math.random() < 0.5) { /* ... trail particle push ... */ this.trailParticles.push(new Particle( this.rocket.x, this.rocket.y, random(-0.3, 0.3), random(-0.3, 0.3), this.rocket.color, random(0.3, 0.7), 'normal', { radius: 1.5, decayRate: 1.8 } )); }
                    if (this.rocket.y <= this.targetHeight || this.rocket.vy >= -1) {
                        this.explode(); // 只觸發視覺爆炸
                    }
                }
                 this.particles.forEach((p, i) => { p.update(deltaTime); if (p.shouldRemove()) this.particles.splice(i, 1); });
                 this.trailParticles.forEach((p, i) => { p.update(deltaTime); if (p.shouldRemove()) this.trailParticles.splice(i, 1); });
            }

            explode() { // *** 不再需要播放音效的程式碼 ***
                if (this.exploded) return;
                this.exploded = true;
                this.rocket.alpha = 0;
                const explosionX = this.rocket.x;
                const explosionY = this.rocket.y;
                const params = this.explosionParams;
                for (let i = 0; i < params.count; i++) { /* ... 原本的粒子生成邏輯 ... */
                     let angle; /* ... calculate angle ... */
                     if (params.shape === 'sphere') { angle = Math.random() * Math.PI * 2; } else if (params.shape === 'ring') { angle = params.angleRange[0] + Math.random() * (params.angleRange[1] - params.angleRange[0]); /* ... wrap around logic ... */ } else if (params.shape === 'directional') { angle = params.angleRange[0] + Math.random() * (params.angleRange[1] - params.angleRange[0]); } else { angle = Math.random() * Math.PI * 2; }
                     const speed = random(0.5, 1.0) * params.speed * (Math.random() > 0.9 ? 1.5 : 1);
                     const vx = Math.cos(angle) * speed; const vy = Math.sin(angle) * speed;
                     const color = this.explosionColors.length > 0 ? this.explosionColors[i % this.explosionColors.length] : randomColor();
                     const life = random(0.8, 1.2) * params.life;
                     this.particles.push(new Particle( explosionX, explosionY, vx, vy, color, life, params.particleType, { /* ... options ... */ gravityFactor: params.gravityFactor, radius: params.radius, decayRate: params.decayRate, strobeRate: params.strobeRate, strobeIntensity: params.strobeIntensity } ));
                }
                this.trailParticles.forEach(p => { p.life *= 0.5; });
            }

            draw() { /* ... 省略，內容和之前一樣 ... */
                 ctx.globalAlpha = 0.6; this.trailParticles.forEach(p => p.draw());
                 ctx.globalAlpha = 1; this.particles.forEach(p => p.draw()); ctx.globalAlpha = 1;
            }
            shouldRemove() { /* ... 省略，內容和之前一樣 ... */
                 return this.exploded && this.particles.length === 0 && this.trailParticles.length === 0;
            }
        }

        // --- 主動畫循環 ---
        function animate(currentTime) {
             requestAnimationFrame(animate);
             if (!lastTime) lastTime = currentTime;
             const deltaTime = currentTime - lastTime;
             lastTime = currentTime;
             if (isNaN(deltaTime) || deltaTime <= 0 || deltaTime > 100) { return; }

             if (soundEnabled) { // *** 聲音啟用後才計時和發射 ***
                mainLoopTimer += deltaTime;

                // 檢查循環重置
                if (mainLoopTimer >= sequenceDuration) {
                    console.log("循環播放...");
                    mainLoopTimer %= sequenceDuration;
                    sequenceIndex = 0;

                    // *** 重置兩種聲音的時間 ***
                    if (bgMusic) {
                         try { bgMusic.currentTime = 0; if(bgMusic.paused){bgMusic.play();} }
                         catch (e) { console.warn("無法重置背景音樂:", e); }
                    }
                    if (fireworksSfxLoop) {
                         try { fireworksSfxLoop.currentTime = 0; if(fireworksSfxLoop.paused){fireworksSfxLoop.play();} }
                         catch (e) { console.warn("無法重置煙火音效:", e); }
                    }
                }

                // --- 發射煙火 ---
                while (sequenceIndex < fireworkSequence.length && fireworkSequence[sequenceIndex].time <= mainLoopTimer) {
                    const event = fireworkSequence[sequenceIndex];
                    const xPos = event.x * vw;
                    const targetY = vh * event.targetHeightFactor; // 計算絕對高度
                    if (xPos > 0 && xPos < vw) {
                         activeFireworks.push(new Firework(xPos, targetY, event.launchSpeed, event.type)); // 傳入 targetY
                    }
                    sequenceIndex++;
                }
             } // <--- soundEnabled 判斷結束

            // --- 繪圖 ---
            ctx.fillStyle = `rgba(0, 0, 0, ${trailLength / 100})`;
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillRect(0, 0, vw, vh);
            ctx.globalCompositeOperation = 'lighter';
            for (let i = activeFireworks.length - 1; i >= 0; i--) {
                 activeFireworks[i].update(deltaTime); activeFireworks[i].draw();
                 if (activeFireworks[i].shouldRemove()) { activeFireworks.splice(i, 1); }
            }
            ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1;
        }

        // --- 初始化聲音 ---
        function initAudio() {
            soundPrompt = document.getElementById('sound-prompt');
            bgMusic = document.getElementById('bgMusic');
            fireworksSfxLoop = document.getElementById('fireworksSfxLoop'); // 取得煙火音效元素

            if (bgMusic) {
                bgMusic.volume = 1.0; // 背景音樂音量最大
                 console.log("背景音樂元素找到，音量設定為 1.0");
            } else {
                console.error("找不到背景音樂元素 #bgMusic");
            }

            if (fireworksSfxLoop) {
                fireworksSfxLoop.volume = 1.0; // 煙火音效音量最大
                 console.log("煙火音效元素找到，音量設定為 1.0");
            } else {
                console.error("找不到煙火音效元素 #fireworksSfxLoop");
            }

            // 監聽點擊以啟用聲音
            soundPrompt.addEventListener('click', enableSound, { once: true });
        }

        // --- 啟用聲音的函數 ---
        function enableSound() {
             if (soundEnabled) return;
             console.log("聲音已由使用者互動啟用。");
             soundEnabled = true;
             soundPrompt.style.display = 'none';

             // *** 嘗試同時播放兩種聲音 ***
             const playPromises = []; // 用來收集播放的 Promise

             if (bgMusic) {
                playPromises.push(bgMusic.play());
             }
             if (fireworksSfxLoop) {
                playPromises.push(fireworksSfxLoop.play());
             }

             // 等待所有聲音都嘗試開始播放後，再同步計時器
             Promise.all(playPromises)
                .then(() => {
                    console.log("背景音樂和煙火音效嘗試開始播放。");
                    // 聲音成功開始 (或嘗試開始) 後，重置計時器
                    mainLoopTimer = 0;
                    sequenceIndex = 0;
                    lastTime = performance.now(); // 使用 performance.now() 獲取更精確的起始時間
                    console.log("主循環計時器已重置與聲音同步。");
                })
                .catch(e => {
                     // 即使有錯誤也要重置計時器，避免完全卡住
                     console.error("至少一個聲音播放失敗:", e);
                     mainLoopTimer = 0;
                     sequenceIndex = 0;
                     lastTime = performance.now();
                     console.warn("儘管聲音播放失敗，主循環計時器仍已重置。");
                });
        }

        // --- 重設畫布大小函數 ---
        function resizeCanvas() { /* ... 省略，內容和之前一樣 ... */
             vw = canvas.width = window.innerWidth;
             vh = canvas.height = window.innerHeight;
        }

        // --- 初始化設定 ---
        function setup() {
             resizeCanvas();
             generateSequence();
             initAudio(); // 初始化聲音
             requestAnimationFrame(animate); // 啟動繪圖循環
             console.log("設定完成，等待使用者互動以啟用聲音。");
        }

        // --- 事件監聽 (窗口大小改變) ---
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
             resizeTimeout = setTimeout(() => {
                console.log("窗口大小改變 - 重新生成序列...");
                resizeCanvas();
                generateSequence();
                if (soundEnabled) { // 只有聲音啟用後才重置計時器和聲音
                    mainLoopTimer = 0;
                    lastTime = performance.now();
                    sequenceIndex = 0;
                    if (bgMusic && !bgMusic.paused) { bgMusic.currentTime = 0; }
                    if (fireworksSfxLoop && !fireworksSfxLoop.paused) { fireworksSfxLoop.currentTime = 0; }
                }
             }, 500);
        });

        // 啟動！
        setup();

    </script>
</body>
</html>